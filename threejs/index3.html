<!DOCTYPE html>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">
<meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<!-- Everything from http://threejs.org/examples/webgl_loader_stl.html -->
<script src="three.min.js"></script>
<script src="Detector.js"></script>
<script src="TrackballControls.js"></script>
<script src="OrbitControls.js"></script>
</head>

<body style="margin:0;padding:0;width:100%;height:100%">
  <div id="ringRender" style="width:100%;height:100%"></div>
</body>
<script>
var height = 0;

if (!Detector.webgl){
  // If no WebGL don't even attempt, Canvas can't handle this task
  Detector.addGetWebGLMessage();
}else{
  var container, camera, cameraTarget, scene, renderer;
  var windowHalfX = 0;
  var windowHalfY = 0;
  init();
  animate();
}

function init() {
  var container = document.getElementById("ringRender");
  camera = new THREE.PerspectiveCamera(2, window.innerWidth / window.innerHeight, 1, 25000);

  // Sets camera position, not camera pivot point
  camera.position.set(1200, 500, -1500.2);
  cameraTarget = new THREE.Vector3(0, 0, 0);
  scene = new THREE.Scene();

  // Reflective background
  scene.fog = new THREE.Fog(0x000000, 20000, 20000);
  // ASCII file
  var path = "pisa/";
  var format = '.png';
  var urls = [
    path + 'px' + format, path + 'nx' + format,
    path + 'py' + format, path + 'ny' + format,
    path + 'pz' + format, path + 'nz' + format
  ];
  var textureCube = THREE.ImageUtils.loadTextureCube(urls);


  // Ring Blank
  var loader = new THREE.JSONLoader();
  loader.load('./10.js', function(geometry) {
    var material = new THREE.MeshPhongMaterial({
      color: 0xA9A9A9,
      specular: 0x000000,
      combine: THREE.MultiplyOperation,
      shininess: 5,
      shading: THREE.SmoothShading,
      reflectivity: 1,
      envMap: textureCube,
      overdraw: true
    })
    var mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(0, 0, 0);

    console.log(mesh);

    geometry.computeBoundingBox();
    var boundingBox = geometry.boundingBox.clone();
    console.log('bounding box coordinates: ' + '(' + boundingBox.min.x + ', ' + boundingBox.min.y + ', ' + boundingBox.min.z + '), ' + '(' + boundingBox.max.x + ', ' + boundingBox.max.y + ', ' + boundingBox.max.z + ')' );
    var bbox = new THREE.BoundingBoxHelper (mesh, "0xff0000");
    height = boundingBox.max.y;

//    scene.add(bbox);
//    bbox.update();
    scene.add(mesh);

    // Top Inlay Cover
    var loaderInlay = new THREE.JSONLoader();
    loaderInlay.load('./10-inlay.js', function(geometry) {
      // Black Top
      var material = new THREE.MeshLambertMaterial({
        color: new THREE.Color(0x000000),
        specular: new THREE.Color(0x000000),
        shininess: 5,
        shading: THREE.SmoothShading,
        reflectivity: 1,
        overdraw: true
      });
      var mesh = new THREE.Mesh(geometry, material);
      console.log("height", height);
      var inlayOffset = height - 2.33063;
      mesh.position.set(0, inlayOffset, 0);
      scene.add(mesh);
    });

    // Bottom Inlay Cover
    var loaderInlay = new THREE.JSONLoader();
    loaderInlay.load('./10-inlay-bottom.js', function(geometry) {
      // Black Top
      var material = new THREE.MeshLambertMaterial({
        color: new THREE.Color(0x000000),
        specular: new THREE.Color(0x000000),
        shininess: 5,
        shading: THREE.SmoothShading,
        reflectivity: 1,
        overdraw: true
      });
      var mesh = new THREE.Mesh(geometry, material);
      console.log("height", height);
      var inlayOffset = - height + 2.33063;
      mesh.position.set(0, inlayOffset, 0); 
      scene.add(mesh);
    });

  });

  // Lights
  addShadowedLight(5, -1, -3, 0xffffff, 2.35);
  addShadowedLight(0, 3, 0, 0xffffff, 1.35);
  addShadowedLight(5, -5, 30, 0xffffff, 2.5);

  // renderer
  renderer = Detector.webgl? new THREE.WebGLRenderer({antialias: true}): new THREE.CanvasRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0xffffff, 1);
  renderer.gammaInput = true;
  renderer.gammaOutput = true;
  renderer.shadowMapEnabled = true;
  renderer.shadowMapCullFace = THREE.CullFaceBack;
  container.appendChild(renderer.domElement);
  window.addEventListener('resize', onWindowResize, false);
  controls = new THREE.OrbitControls(camera);
  controls.damping = 0.2;
  controls.addEventListener('change', render);
}

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  render();
}

function render() {
  renderer.render(scene, camera);
}

function addShadowedLight(x, y, z, color, intensity) {
  var directionalLight = new THREE.DirectionalLight(color, intensity);
  directionalLight.position.set(x, y, z)
  scene.add(directionalLight);
  directionalLight.castShadow = true;
  // directionalLight.shadowCameraVisible = true;
  var d = 1;
  directionalLight.shadowCameraLeft = -d;
  directionalLight.shadowCameraRight = d;
  directionalLight.shadowCameraTop = d;
  directionalLight.shadowCameraBottom = -d;
  directionalLight.shadowCameraNear = 1;
  directionalLight.shadowCameraFar = 4;
  directionalLight.shadowMapWidth = 1024;
  directionalLight.shadowMapHeight = 1024;
  directionalLight.shadowBias = -0.005;
  directionalLight.shadowDarkness = 0.25;
}

function onWindowResize() {
  windowHalfX = window.innerWidth / 2;
  windowHalfY = window.innerHeight / 2;
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

var debugaxis = function(axisLength){
  //Shorten the vertex function
  function v(x,y,z){
    return new THREE.Vector3(x,y,z);
  }
   
  //Create axis (point1, point2, colour)
  function createAxis(p1, p2, color){
    var line, lineGeometry = new THREE.Geometry(),
    lineMat = new THREE.LineBasicMaterial({color: color, lineWidth: 1});
    lineGeometry.vertices.push(p1, p2);
    line = new THREE.Line(lineGeometry, lineMat);
    scene.add(line);
  }
   
  createAxis(v(-axisLength, 0, 0), v(axisLength, 0, 0), 0xFF0000);
  createAxis(v(0, -axisLength, 0), v(0, axisLength, 0), 0x00FF00);
  createAxis(v(0, 0, -axisLength), v(0, 0, axisLength), 0x0000FF);
};

//To use enter the axis length
// debugaxis(100);
</script>
</html>
